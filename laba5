a$ = 0
void foo_if(void) PROC; foo_if
$LN5:
sub     rsp, 24 – выделение в стеке 24 байта.
mov     DWORD PTR a$[rsp], 1 - сохранение значения 1 в памяти по адресу a$[rsp].
cmp     DWORD PTR a$[rsp], 1 - сравнение значения в памяти по адресу a$[rsp] с 1.
jne     SHORT $LN2@foo_if - переход к метке $LN2@foo_if, если значения не равны.
mov     eax, DWORD PTR a$[rsp] - загрузка значения из памяти по адресу a$[rsp] в регистр eax.
add     eax, 10 – прибавление к eax число 1.
mov     DWORD PTR a$[rsp], eax – сохранение eax
jmp     SHORT $LN3@foo_if - безусловный переход к метке $LN3@foo_if.

$LN2@foo_if: (если else)
mov     eax, DWORD PTR a$[rsp] - загрузка значения из памяти по адресу a в регистр eax.
shl     eax, 1 - сдвиг значения в регистре eax на 1 бит влево.
mov     DWORD PTR a$[rsp], eax - сохранения значения из памяти по адресу eax в регистр a.
$LN3@foo_if:
add     rsp, 24 - прибавление 24 к значению регистра rsp, уменьшающее стек.
ret     0 – возврат из текущей процедуры.
void foo_if(void) ENDP; foo_if

//

a$ = 0 
tv64 = 4
Переменная "tv64" является локальной переменной, которая используется в функции foo_switch. Она имеет размер 4 байта и хранится на стеке.
В функции foo_switch значение переменной "a" загружается в регистр eax (mov eax, DWORD PTR a$[rsp]) и затем записывается в переменную "tv64" (mov DWORD PTR tv64[rsp], eax). Переменная "tv64" используется для определения значения, на основе которого будет выбрана одна из веток в конструкции switch.

void foo_switch(void) PROC; foo_switch
$LN7:
sub     rsp, 24 - выделение в стеке 24 байта.
mov     DWORD PTR a$[rsp], 0 - сохранение значения 0 в a.
mov     eax, DWORD PTR a$[rsp] - загрузка значения из памяти по адресу a$[rsp] в регистр eax.
mov     DWORD PTR tv64[rsp], eax - сохранение значения из регистра eax в памяти по адресу tv64[rsp].
cmp     DWORD PTR tv64[rsp], 0 - сравнение значения в памяти по адресу tv64[rsp] с 1.
je      SHORT $LN4@foo_switch - переход к метке $LN4@foo_switch, если значения равны.
cmp     DWORD PTR tv64[rsp], 1 - cравнение значения в памяти по адресу tv64[rsp] с 1.
je      SHORT $LN5@foo_switch - переход к метке $LN5@foo_switch, если значения равны.
jmp     SHORT $LN2@foo_switch - безусловный переход к метке $LN2@foo_switch.

$LN4@foo_switch:
mov     eax, DWORD PTR a$[rsp] - загрузка значения из памяти по адресу a$[rsp] в регистр eax.
add     eax, 10 - прибавление 10 к значению в регистре eax.
mov     DWORD PTR a$[rsp], eax - загрузка значения из памяти по адресу a$[rsp] в регистр eax.
jmp     SHORT $LN2@foo_switch - безусловный переход к метке $LN2@foo_if.

$LN5@foo_switch:
mov     eax, DWORD PTR a$[rsp] - загрузка значения из памяти по адресу a$[rsp] в регистр eax.
shl     eax, 1 - сдвиг значения в регистре eax на 1 бит влево.
mov     DWORD PTR a$[rsp], eax
$LN2@foo_switch:
add     rsp, 24 - прибавление 24 к значению регистра rsp, уменьшающее стек.
ret     0 -  возврат из текущей процедуры.
void foo_switch(void) ENDP; foo_switch

//

a$ = 0
tv67 = 4
Переменная tv67 - это переменная, используемая в функции foo_ternary. В зависимости от значения переменной "a", она может содержать результат сложения 10 к переменной "a" или результат умножения переменной "a" на 2. Значение переменной tv67 в конечном итоге записывается обратно в переменную "a".

void foo_ternary(void) PROC; foo_ternary

$LN5:
sub     rsp, 24 – выделение 24 байта в стеке.
mov     DWORD PTR a$[rsp], 0 - сохранение значения 0 в памяти по адресу a$[rsp].
cmp     DWORD PTR a$[rsp], 1 – сравнение значения в памяти по адресу a$[rsp] с 1.
jne     SHORT $LN3@foo_ternar - переход к метке $LN2@foo_if, если значения не равны.
mov     eax, DWORD PTR a$[rsp] – загрузка значения из памяти по адресу a$[rsp] в регистр eax.
add     eax, 10 – прибавление 10 к значению в регистре eax.
mov     DWORD PTR tv67[rsp], eax - загрузка значения из памяти по адресу a$[rsp] в регистр eax.
jmp     SHORT $LN4@foo_ternar - безусловный переход к метке $LN4@foo_ternar.

$LN3@foo_ternar:
mov     eax, DWORD PTR a$[rsp] - загрузка значения из памяти по адресу tv67[rsp] в регистр eax.
shl     eax, 1 - сдвиг значения в регистре eax на 1 бит влево.
mov     DWORD PTR tv67[rsp], eax - сохранение значения из регистра eax в памяти по адресу tv67[rsp].

$LN4@foo_ternar:
mov     eax, DWORD PTR tv67[rsp] - загрузка значения из памяти по адресу tv67[rsp] в регистр eax.
mov     DWORD PTR a$[rsp], eax - сохранение значения из регистра eax в памяти по адресу a$[rsp].
add     rsp, 24 - прибавление 24 к значению регистра rsp, уменьшающее стек.
ret     0 - возврат из текущей процедуры.
void foo_ternary(void) ENDP; foo_ternary
(Команда sub rsp, 24 означает вычитание значения 24 из регистра rsp (stack pointer или указатель стека).)
Чтобы освободить выделенное место на стеке в конце функции, обычно используется команда add rsp, 24, которая добавляет 24 к значению регистра rsp для возвращения вершины стека в исходную позицию

.

Различия между функциями `foo_if`, `foo_switch` и `foo_ternary` касаются структуры их реализации и выбора действий в зависимости от условий.

1. `foo_if`:
   - Внутри функции используется условный оператор `if` для проверки значения переменной "a".
   - Если значение переменной "a" равно 1, то к нему прибавляется 10, а затем значение записывается обратно в переменную "a". В противном случае, значение переменной "a" умножается на 2.
   - Используется безусловный переход `jmp` для перехода к последнему блоку кода.
   
2. `foo_switch`:
   - Внутри функции используется конструкция `switch` для проверки значения переменной "tv64".
   - В зависимости от значения переменной "tv64", выбирается одна из трех веток:
     - Если значение равно 0, то к значению переменной "a" прибавляется 10.
     - Если значение равно 1, то значение переменной "a" умножается на 2.
     - Если значение не равно 0 или 1, выполняется безусловный переход к метке $LN2@foo_switch.
   - Используется безусловный переход `jmp` для перехода к последнему блоку кода.

3. `foo_ternary`:
   - Внутри функции используется тернарный оператор `? :` для проверки значения переменной "a".
   - Если значение переменной "a" равно 1, к нему прибавляется 10 и результат записывается в переменную "tv67". Если значение не равно 1, значение переменной "a" умножается на 2 и результат записывается в переменную "tv67".
   - Затем значение переменной "tv67" записывается обратно в переменную "a".


foo_if: В этой функции условие проверяется с помощью оператора if. Если условие истинно, то выполняются определенные действия. В противном случае, выполняются другие действия или может быть выполнено условие else if или else. В данной функции, значение переменной "a" сравнивается с 1 и на основе результата выполняются различные операции. Если "a" равно 1, к "a" прибавляется 10, иначе "a" умножается на 2.

foo_switch: В этой функции условие проверяется с помощью оператора switch. Значение переменной "tv64" сравнивается с определенными значениями и в зависимости от результата выбирается определенный блок кода для выполнения. Если значение "tv64" равно 0, к переменной "a" прибавляется 10, если равно 1, то "a" умножается на 2. Если значение "tv64" не равно ни одному из указанных, выполняется блок кода по умолчанию.

foo_ternary: В этой функции условие проверяется с помощью оператора "тернарный оператор". Условие проверяет, равно ли значение переменной "a" 1. Если условие истинно, то результатом выражения будет сложение 10 и "a", в противном случае результатом будет умножение "a" на 2. Результат записывается в переменную "tv67". Затем значение "tv67" записывается обратно в переменную "a".
